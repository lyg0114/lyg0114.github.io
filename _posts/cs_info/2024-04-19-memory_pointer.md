---
title: "포인터로 메모리를 직접 다루어 보기"
date: 2024-04-19 08:40:00 +09:00
categories: [ cs ]
tags:
  [
    cs, computer, os, structure, memory, ram, pointer
  ]
---

자바 개발자로 살다보면, 메모리 관리를 JVM이 대신 해주기 때문에 메모리에대해 깊게 고민해볼 기회가 많지 않다. 당연히 메모리에대한 이해가떨어지게되고 개인적으로는 장기적인 관점에 좋은 선택이 아니라고 생각한다.
최근 C언어를 학습하며 컴퓨터 자체에대해 좀더 깊게 공부하려고 노력 중이다. (사실 학교다닐때 열심히 공부했어야 했던것들..)
오늘은 포인터를 통해 메모리가 어떤식으로 동작하는지 정리해 보았다.

## 메모리
메모리는 컴퓨터가 프로그램을 실행하고 데이터를 저장하는 데 사용하는 장치 이다. 메모리는 물리적인 RAM(랜덤 액세스 메모리)과 가상 메모리로 나눌 수 있다.

#### 가상 메모리
생각해보자 사람들이 사용하는 메모리의 용량은 생각보다 크지 않다. 요즘은 메로리 용량이 많이 올라 갔지만, 평균적으로 8GB ~ 16GB 정도라고 할 수 있겠다. 우리가 사용하는 프로그램들의 용량을 생각해 보자 
예를 들어 엑셀을 띄워높고, 크롬텝 여러개를 생성해서 ppt를 만든다고 가정해 보자. 
모르긴해도 상당한 메모리 공간이 필요할 것이다. 물리적인 메모리용량 만으로는 이 모든 프로그램들을 안정적으로 운용하기 쉽지 않다. 여기서 등장하는것이 바로 `가상 메모리` 이다. 

_물리적인 메모리공간 뿐만 아니라 디스크(SSD, HDD)의 까지 마치 메모리인것처럼 추상화하여 사용하는 것이다._
프로세스는 OS에게 메모리를 요청하고 OS는 메모리를 할당해 준다. 프로세스는 이 공간이 실제 메모리 영역인지, 디스크 영역인지 고려하지 않는다. 단지 하나의 큰 메모리로 인식할 뿐이다.
이러한 큰 가상의 메모리를 OS가 내부적으로 관리하는 것이다. 응집도가 높다고 볼 수 있겠다. 요즘엔 대부분 SSD를 사용하기 때문에 눈에띄는 성능 저하는 없겠지만, HDD를 사용한다면 중간중간 프로그램이 느려지는 현상을 느낄 수 있을 것이다.

## 포인터
포인터는 C / C++ 에서 지원하는 문법인데 메모리의 주소를 개발자가 직접 다룰 수 있는 아주 강력한 방법이다. 포인터를 이용해 메모리에 직접적으로 접근할 수 있는 만큼 개발자에게 높은 자유가 주어진다.
잘 사용하면 아주빠른 성능을 낼 수 있겠으나, 메모리를 잘못건드린 모든 개나는 개발자의 몫이다. 

이런면에서 메모리를 관리해주는 Java가 좀더 안정적이긴 하다. 컴퓨터의 세계는 모든것이 선택과 집중이다.
다시 돌아와서 _포인터는 포인터는 메모리 주소를 저장하는 변수로, 다른 변수나 데이터 구조체의 위치를 가리키는 역할을 한다._ 이를 통해 변수의 값을 변경하거나 참조할 수 있다. 아래의 코드를 한번 보자

```c
int main() {
    int num = 10;
    int * ptr = &num;
    
    printf("변수 num의 값: %d\n", num);
    printf("포인터 ptr이 가리키는 값: %d\n", *ptr);
    return 0;
}
```

* `int num = 10;`
  * num이라는 변수에 10을 할당하는 코드 이다. num변수의 메모리 주소는 OS에 의해 결정 된다.
    ![memory-image1](/assets/img/memory-image1.jpg)
  * 위의 그림을 보면 `0x00007ff7bb85b428` 주소를 기준으로 `4Byte` 만큼 메모리에 공간(Stack 영역)이 할당된 것을 확인할 수 있다. num의 값에 접근하기 위해서는 `0x00007ff7bb85b428` 주소값이 필요한 것이다. 
* `int * ptr = &num;`
  * 그렇다면 포인터란 무엇인가, 가리킨다는 뜻이다. 무엇을? 주소값을, 즉 메모리의 주소값을 가리키는 것이라 생각하면 된다.
    ![memory-image2](/assets/img/memory-image2.jpg)
  * 위의 그림을 통해 `ptr`에 어떤값이 저장되어있는지 확인해 보자 `8Byte` 공간이 할당 되었고 정확히 `0x00007ff7bb85b428` 값`(num의 주소값)`이 저장되어 있는것을 확인할 수 있다. 
  * 흥미로운점은 주소값이 `1Byte`씩 저장되는데 메모리의 가장 뒤쪽부터 저장된다는 것이다. 나의 PC는 인텔 칩을 사용하는데 인텔은 `리틀엔디안` (메모리의 가장 낮은 바이트 부터 데이터를 저장하는 방식) 방식을 따르기 때문에 그렇다.

### 주소값을 저장하는 공간에 8Byte가 할당되는 이유
변수를 사용하면 변수의 크기만큼 메모리에 공간이 할당된다. 아래는 각 타입별 크기를 정리한 것이다.

| 타입          | 크기                             |
|-------------|--------------------------------|
| char        | 1 Byte                         |
| short       | 2 Byte                         |
| int         | 4 Byte                         |
| long        | 4 Byte(32bit) 또는 8 Byte(64bit) |
| long long   | 8 Byte                         |
| float       | 4 Byte                         |
| double      | 8 Byte                         |
| long double | 10 Byte 이상                     |

그렇다면 메모리공간에, 메모리 주소값을 저장하려면 얼만큼의 공간이 필요할까? 여기서 고려해야할것은 CPU가 몇 bit 프로세서인지를 알아야 한다. 요즘나오는 대부분의 CPU는 64bit를 지원한다.
_64bit 프로세서는 데이터의 주소, 레지스터 및 데이터 버스의 너비가 64bit인 프로세서를 말한다._ 이는 프로세서가 한 번에 처리할 수 있는 데이터 크기가 64bit임을 의미합니다. 즉 메모리의 주소값을 64bit값으로 다루겠다는 것이다. 처리한다는 말이다.
즉 64bit(8Byte)의 공간이 필요한 것이다. 

* 64bit 시스템은 1Byte 메모리에 부여하는 주소가 `64비트 상수`인 것이다.
  ![memory-image3](/assets/img/memory-image3.jpg)

## 결론
오랫동안 자바를 사용하면서 애써 외면해 왔던것들을 다시 펼쳤다. 실력있는 개발자가 되기위해 반드시 짚고 넘어가야할 부분이라 생각한다. 컴퓨터의 동작 원리에대해 앞으로 좀더 깊게 공부해 보아야 겠다.
